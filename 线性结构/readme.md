## 数组
  数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。
  特点： 
    - 线性表（Linear List）： 线性表就是数据排成像一条线一样的结构。
    - 连续的内存空间和相同类型的数据。
  正确的表述应该是，数组支持随机访问，根据下标随机访问的时间复杂度为O(1)。
  低效的“插入”和“删除”
  寻址公式： a[i]_address = base_address + i * data_type_size
  1. 为什么数组要从0开始编号，而不是从1开始呢？
    “下标”最确切的定义应该是“偏移（offset）”
    从0开始： a[k]_address = base_address + k * type_size
    从1开始： a[k]_address = base_address + (k-1)*type_size
    如果下标从1开始，那么每次随机访问数组元素都多了一次减法运算，对于CPU来说，就是多了一次减法指令。


## 链表
  链表通过“指针”将一组零散的内存块串联起来使用
  单链表，双向链表，循坏链表
  插入，删除性能高
  常见的缓存策略：
    先进先出策略FIFO（First In，First Out）、最少使用策略LFU（Least Frequently Used）、最近最少使用策略LRU（Least Recently Used）。
  1. 理解指针或引用的含义
  2. 警惕指针丢失和内存泄漏
  3. 利用哨兵简化实现难度
  4. 重点留意边界条件处理(为空，一个结点，两个结点，头结点，尾结点)
  5. 举例画图，辅助思考


## 栈
  后进者先出，先进者后出，这就是典型的“栈”结构。栈是一种“操作受限”的线性结构。
  栈场景：
    浏览器前进后退，函数执行栈，运算表达式(保存操作数的栈，保存运算符的栈)，括号匹配


## 队列
  先进者先出，这就是典型的“队列”。队列也是一种“操作受限”的线性结构。
  顺序队列(数组实现)和链式队列(链表实现)
  head   tail   循坏队列
  阻塞队列其实就是在队列基础上增加了阻塞操作。(空取数据阻塞，满插数据阻塞)(生产者-消费者)
  并发队列
  实际上，我们在出队时可以不用搬移数据。如果没有空闲空间了，我们只需要在入队时，再集中触发一次数据的搬移操作。(数组的删除等也如此)
  场景： 线程池，，消息队列

## 跳表  基于链表的二分查找
  这种链表加多级索引的结构，就是跳表。
  Redis中用跳表来实现有序集合
  链表中查询一个节点->O(n)
  跳表中查询一个节点->O(logn)
  跳表索引动态更新 -> 通过随机函数，随机函数生成了值K，那我们就将这个结点添加到第一级到第K级这K级索引中。


  ## 散列表
    散列表用的是数组支持按照下标随机访问数据的特性，所以散列表其实就是数组的一种扩展，由数组演化而来。可以说，如果没有数组，就没有散列表。
    key -> 下标  散列函数(哈希函数)(转为ASCII，取模)
    散列冲突
      1. 开放寻址法 (往后面找)
        线性探测(装载因子)，二次探测，双重散列
      2. 链地址法 (当前生成一个链表，bucket桶放在多个slot)
    场景： Word文档中单词拼写检查功能

    散列表的查询效率并不能笼统地说成是O(1)。它跟散列函数、装载因子、散列冲突等都有关系。如果散列函数设计得不好，或者装载因子过高，都可能导致散列冲突发生的概率升高，查询效率下降。

    哈希算法：将任意长度的二进制值串映射为固定长度的二进制值串，这个映射的规则就是哈希算法，而通过原始数据映射之后得到的二进制值串就是哈希值
     1. 唯一标识
     2. 校验数据的完整性和正确性
     3. 安全加密
     4. 散列函数
     5. 负载均衡
     6. 数据分片
     7. 分布式存储
