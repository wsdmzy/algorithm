## 排序
  - 冒泡，插入，选择    O(n^2)    基于比较
  - 快排，归并         O(nlogn)   基于比较
  - 桶，计数，基数     O(n)       不基于比较


  稳定的排序算法(相同的元素，位置顺序不变)和不稳定的排序算法。
    场景： 对订单进行排序，先进行下单时间排序，然后在进行总金额稳定排序

  1. 冒泡排序（Bubble Sort）(相邻元素两两比较，交换)
    1. 原地算法
    2. 稳定的排序算法
    3. 最好O(1) 最坏O(n^2)   平均时间复杂度就是加权平均期望时间复杂度

  2. 插入排序（Insertion Sort）(将元素插入已排序区间)
    1. 原地算法
    2. 稳定的排序算法
    3. 最好O(n) 最坏O(n^2)

  3. 选择排序（Selection Sort）(选择min添加至已排序区间末尾)
    1. 原地算法
    2. 不稳定的排序算法
    3. 最好 最坏O 都是(n^2)

- 为什么插入排序比冒泡排序更受欢迎？
  冒泡排序的数据交换要比插入排序的数据移动要复杂，冒泡排序需要3个赋值操作，而插入排序只需要1个

  插入排序的优化，希尔排序？ 也称为缩小增量排序
    希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。
       最坏的情况O(n^2) 通常都优于O(n^2)


  4. 归并排序（Merge Sort）(依次分解成单个，合并排序) 分治思想
    如果要排序一个数组，我们先把数组从中间分成前后两部分，然后对前后两部分分别排序，再将排好序的两部分合并在一起，这样整个数组就都有序了。
    1. 稳定的排序算法
    2. 不管是最好情况、最坏情况，还是平均情况，时间复杂度都是O(nlogn)。
    3. 非原地算法，  O(n)

  5. 快速排序 (Quick sort) 分治思想 (分区点，小于在左边，大于在右边)
    快排是一种原地、不稳定的排序算法。 快排的时间复杂度也是O(nlogn)。

  
  6. 堆排序  (选择排序，堆结构，堆顶元素和末尾元素互换) 
    堆： 类似于二叉树，但不是，根节点大于子节点，大顶堆arr[i]>= arr[2i+1] arr[2i+2]，小顶堆
    1. 将无需序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆;
    2. 将堆顶元素与末尾元素交换，将最大元素"沉"到数组末端;
    3. 重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。
    原地算法，不稳定的   时间复杂度O(nlogn)

  7. 桶排序（Bucket sort） (订单金额排序)
    核心思想是将要排序的数据分到几个有序的桶里，每个桶里的数据再单独进行排序。桶内排完序之后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的了。
    桶内元素用快排
    时间复杂度 O(n)   极端情况数据分到一个桶内O(nlogn)

  8. 计数排序（Counting sort） (高考分数)
    计数排序其实是桶排序的一种特殊情况。
      当要排序的n个数据，最大值是K，划分K个桶，每个桶内的数据值都是相同的，省掉了桶内排序的时间。

  9. 基数排序（Radix sort）
    1）比较两个手机号码a，b的大小，如果在前面几位中a已经比b大了，那后面几位就不用看了。
    2）借助稳定排序算法的思想，可以先按照最后一位来排序手机号码，然后再按照倒数第二位来重新排序，以此类推，最后按照第一个位重新排序。
    3）经过11次排序后，手机号码就变为有序的了。
    基数排序对要排序的数据是有要求的，需要可以分割出独立的“位”来比较，而且位之间有递进的关系，如果a数据的高位比b数据大，那剩下的低位就不用比较了。除此之外，每一位的数据范围不能太大，要可以用线性排序算法来排序，否则，基数排序的时间复杂度就无法做到O(n)了。